---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.13.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```python
import os
from collections import Counter, deque, defaultdict
from copy import deepcopy
from datetime import datetime, timedelta
from statistics import median
from time import sleep

import aocd
import numpy as np
import pandas as pd
from aocd import submit
from aocd.models import Puzzle
from tqdm import tqdm


def fetch_day(day, year=2021):
    global data, lines
    while datetime.now() < datetime(year=year, month=12, day=1, hour=23) + timedelta(
        days=day - 2
    ):
        sleep(2)
    puzzle = Puzzle(year=year, day=day)
    data = puzzle.input_data
    lines = data.split("\n")
```

<!-- #region heading_collapsed=true -->
## Day 1
<!-- #endregion -->

```python hidden=true
fetch_day(1)
nums = [int(x) for x in lines]
```

```python hidden=true
sum(x < y for x, y in zip(nums, nums[1:]))
```

```python hidden=true
sum(x < y for x, y in zip(nums, nums[3:]))
```

<!-- #region heading_collapsed=true -->
## Day 2
<!-- #endregion -->

```python hidden=true
fetch_day(2)
```

```python hidden=true
stuff = [x.split(" ") for x in lines]
stuff = [(x, int(y)) for x, y in stuff]
```

```python hidden=true
d, f, u = pd.DataFrame(stuff).groupby(0).sum()[1]
f * (d - u)
```

```python hidden=true
aim = 0
depth = 0
h = 0
for x, y in stuff:
    if x == "forward":
        h += y
        depth += aim * y
    else:
        aim += y * (1 if x == "down" else -1 if x == "up" else 0)
aim * h, depth * h
```

<!-- #region heading_collapsed=true -->
## Day 3
<!-- #endregion -->

```python hidden=true
fetch_day(3)
```

```python hidden=true
nums = np.array([list(x) for x in lines])
```

```python hidden=true

counters = [Counter(nums[:, i]) for i in range(nums.shape[1])]
best = int("".join(max(x, key=x.__getitem__) for x in counters), 2)
print(best * (2 ** nums.shape[1] - 1 - best))
```

```python hidden=true
def criteria(nums, idx=0, direction="max"):
    fcn = max if direction == "max" else min
    if nums.shape[0] == 1:
        return int("".join(nums[0]), 2)
    x = Counter(nums[:, idx])
    if len(set(x.values())) == 2:
        z = fcn(x, key=x.__getitem__)
    else:
        z = "1" if direction == "max" else "0"
    return criteria(
        nums[nums[:, idx] == z, :],
        direction=direction,
        idx=idx + 1,
    )


print(criteria(nums, direction="min") * criteria(nums, direction="max"))
```

<!-- #region heading_collapsed=true -->
## Day 4
<!-- #endregion -->

```python hidden=true
fetch_day(4)
```

```python hidden=true
import re


class Board:
    winners = []

    def __init__(self, nums):
        self.board = []
        for line in nums:
            self.board.append(
                [int(x) for x in re.sub("^ ", "", re.sub(" +", " ", line)).split(" ")]
            )
        self.board = np.array(self.board)
        self.punched = np.full([5, 5], False)
        self.last_called = 0
        self.won = False

    def punch(self, num):
        if self.won:
            return
        self.punched |= self.board == num
        self.last_called = num
        if self.check_win():
            self.winners.append(self)

    def check_win(self):
        self.won = (
            self.won
            or any(all(self.punched[x, :]) for x in range(5))
            or any(all(self.punched[:, x]) for x in range(5))
        )
        return self.won

    def get_score(self):
        return (self.board * ~self.punched).sum() * self.last_called


def parse(lines):
    return [int(x) for x in lines[0].split(",")], [
        Board(lines[idx : idx + 5]) for idx in range(2, len(lines), 6)
    ]


called, boards = parse(lines)

for call in called:
    for idx, board in enumerate(boards):
        board.punch(call)

print(Board.winners[0].get_score(), Board.winners[-1].get_score())
```

<!-- #region heading_collapsed=true -->
## Day 5
<!-- #endregion -->

```python hidden=true
fetch_day(5)
```

```python hidden=true
def parse_line(line):
    x, y = line.split(" -> ")
    x, y = x.split(","), y.split(",")
    return list(map(int, x)), list(map(int, y))


lines = list(map(parse_line, lines))

c = Counter()
c2 = Counter()
for x, y in lines:
    if x[0] == y[0]:
        m, M = min(x[1], y[1]), max(x[1], y[1])
        for idx in range(m, M + 1):
            c[(x[0], idx)] += 1
    elif x[1] == y[1]:
        m, M = min(x[0], y[0]), max(x[0], y[0])
        for idx in range(m, M + 1):
            c[(idx, x[1])] += 1
    else:
        m, n, M, N = (*x, *y)
        if n > N:
            m, M, n, N = M, m, N, n
        for idx in range(n, N + 1):
            if m < M:
                c2[(m + idx - n, idx)] += 1
            else:
                c2[(m - idx + n, idx)] += 1

print(sum(v > 1 for k, v in c.items()))
print(sum(v > 1 for k, v in (c + c2).items()))
```

<!-- #region heading_collapsed=true -->
## Day 6
<!-- #endregion -->

```python hidden=true
fetch_day(6)
```

```python hidden=true
nums = list(map(int, lines[0].split(",")))
cnums = Counter(nums)


def cevolve(cnums):
    out = Counter()
    for k, v in cnums.items():
        if k > 0:
            out[k - 1] += v
        else:
            out[6] += v
            out[8] += v
    return out


for idx in range(80):
    cnums = cevolve(cnums)
print(sum(cnums.values()))
for idx in range(256 - 80):
    cnums = cevolve(cnums)
print(sum(cnums.values()))
```

<!-- #region heading_collapsed=true -->
## Day 7
<!-- #endregion -->

```python hidden=true
fetch_day(7)
```

```python hidden=true
nums = list(map(int, lines[0].split(",")))
```

```python hidden=true
min(sum(abs(m - y) * (abs(m - y) + 1) // 2 for y in nums) for m in range(1911))
```

<!-- #region heading_collapsed=true -->
## Day 8
<!-- #endregion -->

```python hidden=true
fetch_day(8)
```

```python hidden=true
digits = [
    (1, 1, 1, 0, 1, 1, 1),
    (0, 0, 1, 0, 0, 1, 0),
    (1, 0, 1, 1, 1, 0, 1),
    (1, 0, 1, 1, 0, 1, 1),
    (0, 1, 1, 1, 0, 1, 0),
    (1, 1, 0, 1, 0, 1, 1),
    (1, 1, 0, 1, 1, 1, 1),
    (1, 0, 1, 0, 0, 1, 0),
    (1, 1, 1, 1, 1, 1, 1),
    (1, 1, 1, 1, 0, 1, 1),
]

letter_map = dict(zip(range(7), "abcdefg"))
correct_digits = [
    "".join(letter_map[idx] for idx, v in enumerate(d) if v) for d in digits
]
check = list(sorted(correct_digits))

from itertools import permutations


def apply_map(l, lmap="abcdefg"):
    lmap = dict(zip("abcdefg", list(lmap)))
    return ["".join(sorted(map(lmap.__getitem__, x))) for x in l]


def sort_letters(letters):
    letters = letters.split(" ")
    return apply_map(letters)


def parse_line(line):
    l, out = map(sort_letters, line.split(" | "))
    s = list(map(len, l))
    for perm in permutations("abcdefg"):
        l_test = apply_map(l, perm)
        if check == list(sorted(l_test)):
            out = apply_map(out, perm)
            return [correct_digits.index(x) for x in out]


sol = list(map(parse_line, tqdm(lines)))

c = sum((Counter(x) for x in sol), Counter())
print(sum(c[int(x)] for x in "1478"))
print(sum(int("".join(map(str, x))) for x in sol))
```

<!-- #region heading_collapsed=true -->
## Day 9
<!-- #endregion -->

```python hidden=true
fetch_day(9)
```

```python hidden=true
# Part 1

nums = np.array([list(map(int, x)) for x in lines])
valid = []
m, n = nums.shape


def neighbors(x, y):
    out = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
    return [(a, b) for a, b in out if 0 <= a < m and 0 <= b < n]


minimums = {
    (x, y)
    for x in range(m)
    for y in range(n)
    if all(nums[cx, cy] > nums[x, y] for cx, cy in neighbors(x, y))
}
print(sum(nums[x, y] + 1 for x, y in minimums))

# Part 2


def area(loc):
    x, y = loc
    if nums[x, y] in {-1, 9}:
        return 0
    nums[x, y] = -1
    return 1 + sum(map(area, neighbors(x, y)))


np.prod(sorted(map(area, minimums))[-3:])
```

<!-- #region heading_collapsed=true -->
## Day 10
<!-- #endregion -->

```python hidden=true
fetch_day(10)
```

```python hidden=true
match = dict(zip("([{<", ")]}>"))


def check_line(line):
    score = 0
    q = deque()
    score_map = dict(zip(")]}>", [3, 57, 1197, 25137]))
    score_map_2 = dict(zip("([{<", [1, 2, 3, 4]))
    part1, part2 = 0, 0
    try:
        for c in line:
            if c in "([{<":
                q.append(c)
            else:
                if c != match[q.pop()]:
                    part1 = score_map[c]
                    raise ValueError
    except ValueError:
        pass
    else:
        while q:
            c = q.pop()
            part2 *= 5
            part2 += score_map_2[c]
    finally:
        return part1, part2


output = list(map(check_line, lines))
print(sum(x for x, _ in output))
print(median(x for _, x in output if x > 0))
```

<!-- #region heading_collapsed=true -->
## Day 11
<!-- #endregion -->

```python hidden=true
fetch_day(11)
```

```python hidden=true
class Flash:
    def __init__(self, lines):
        self.N = len(lines)
        self.grid = np.array([list(map(int, line)) for line in lines])
        self.flashcount = 0

    def print(self):
        print(self.grid)

    def step(self):
        self.grid += 1
        flashed = True
        self.flashgrid = np.full((self.N, self.N), False)
        while flashed:
            flashed = False
            flashes = [
                (x, y)
                for x in range(self.N)
                for y in range(self.N)
                if self.grid[x, y] > 9
            ]
            flashed = bool(flashes)
            for x, y in flashes:
                self.flash(x, y)
            self.grid[self.flashgrid] = 0

    def flash(self, x, y):
        if self.flashgrid[x, y]:
            return
        self.flashgrid[x, y] = True
        self.grid[
            max(0, x - 1) : min(self.N, x + 2),
            max(0, y - 1) : min(self.N, y + 2),
        ] += 1
        self.flashcount += 1


f = Flash(lines)
for idx in range(100):
    f.step()
print(f.flashcount)
for idx in range(100000):
    f.step()
    if all(f.flashgrid.flatten()):
        print(idx + 101)
        break
```

<!-- #region heading_collapsed=true -->
## Day 12
<!-- #endregion -->

```python hidden=true
fetch_day(12)
```

```python hidden=true
graph = defaultdict(set)
for line in lines:
    x, y = line.split("-")
    if y != "start":
        graph[x].add(y)
    if x != "start":
        graph[y].add(x)

valid_walks = 0
stack = deque([(("start",), {"start"})])

while stack:
    walk, visited = stack.pop()
    for v in graph[walk[-1]] - visited:
        if v == "end":
            valid_walks += 1
        else:
            stack.append(
                (
                    walk + (v,),
                    visited | {v} if v == v.lower() else visited,
                )
            )

print(valid_walks)
```

```python hidden=true
graph = defaultdict(set)
for line in lines:
    x, y = line.split("-")
    if y != "start":
        graph[x].add(y)
    if x != "start":
        graph[y].add(x)

valid_walks = 0
stack = deque([(("start",), {"start"}, False)])

while stack:
    walk, visited, visited_twice = stack.pop()
    for v in graph[walk[-1]]:
        if v == "end":
            valid_walks += 1
        elif v not in visited or not visited_twice:
            stack.append(
                (
                    walk + (v,),
                    visited | {v} if v == v.lower() else visited,
                    visited_twice or (v in visited),
                )
            )

print(valid_walks)
```

<!-- #region heading_collapsed=true -->
## Day 13
<!-- #endregion -->

```python hidden=true
fetch_day(13)
```

```python hidden=true
it = iter(lines)
points = set()
folds = []
while line := next(it):
    points.add(tuple(map(int, line.split(","))))
for line in it:
    eq_idx = line.find("=")
    folds.append((line[eq_idx - 1], int(line[eq_idx + 1 :])))


def transform(points, fold):
    d, z = fold
    if d == "x":
        return {(min(x, 2 * z - x), y) for x, y in points}
    else:
        return {(x, min(y, 2 * z - y)) for x, y in points}


print(len(transform(points, folds[0])))

for fold in folds:
    points = transform(points, fold)

M, N = max(x for x, _ in points), max(y for _, y in points)
grid = np.full((M + 1, N + 1), " ")

for x, y in points:
    grid[x, y] = "█"
print("\n".join("".join(row) for row in grid.T))
```

<!-- #region heading_collapsed=true -->
## Day 14
<!-- #endregion -->

```python hidden=true
fetch_day(14)
```

```python hidden=true
chem = lines[0]
rules = dict(line.split(" -> ") for line in lines[2:])
adj = Counter(chem[i : i + 2] for i in range(len(chem) - 1))
for iterations in (10, 40):
    for _ in range(iterations):
        update = Counter()
        for k, v in adj.items():
            if k in rules:
                update[k] -= v
                update[k[0] + rules[k]] += v
                update[rules[k] + k[1]] += v
        adj += update

    c = Counter()
    for k, v in adj.items():
        c[k[0]] += v
    c[chem[-1]] += 1
    l = [v for k, v in c.items()]
    print(max(l) - min(l))
```

## Day 15

```python
fetch_day(15)
```
