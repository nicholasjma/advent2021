---
jupyter:
  jupytext:
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.13.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

## Imports

```python
import heapq
import math
import os
import re
from collections import Counter, defaultdict, deque
from copy import deepcopy
from datetime import datetime, timedelta
from dataclasses import dataclass
from functools import lru_cache, reduce
from itertools import takewhile
from statistics import median
from time import sleep

import aocd
import networkx as nx
import numpy as np
import pandas as pd
from aocd import submit
from aocd.models import Puzzle
from tqdm import tqdm


def fetch_day(day, year=2021):
    global data, lines
    while datetime.now() < datetime(year=year, month=12, day=1, hour=23) + timedelta(
        days=day - 2
    ):
        sleep(2)
    puzzle = Puzzle(year=year, day=day)
    data = puzzle.input_data
    lines = data.split("\n")
```

<!-- #region heading_collapsed=true -->
## Day 1
<!-- #endregion -->

```python hidden=true
fetch_day(1)
nums = [int(x) for x in lines]
```

```python hidden=true
sum(x < y for x, y in zip(nums, nums[1:]))
```

```python hidden=true
sum(x < y for x, y in zip(nums, nums[3:]))
```

<!-- #region heading_collapsed=true -->
## Day 2
<!-- #endregion -->

```python hidden=true
fetch_day(2)
```

```python hidden=true
stuff = [x.split(" ") for x in lines]
stuff = [(x, int(y)) for x, y in stuff]
```

```python hidden=true
d, f, u = pd.DataFrame(stuff).groupby(0).sum()[1]
f * (d - u)
```

```python hidden=true
aim = 0
depth = 0
h = 0
for x, y in stuff:
    if x == "forward":
        h += y
        depth += aim * y
    else:
        aim += y * (1 if x == "down" else -1 if x == "up" else 0)
aim * h, depth * h
```

<!-- #region heading_collapsed=true -->
## Day 3
<!-- #endregion -->

```python hidden=true
fetch_day(3)
```

```python hidden=true
nums = np.array([list(x) for x in lines])
```

```python hidden=true

counters = [Counter(nums[:, i]) for i in range(nums.shape[1])]
best = int("".join(max(x, key=x.__getitem__) for x in counters), 2)
print(best * (2 ** nums.shape[1] - 1 - best))
```

```python hidden=true
def criteria(nums, idx=0, direction="max"):
    fcn = max if direction == "max" else min
    if nums.shape[0] == 1:
        return int("".join(nums[0]), 2)
    x = Counter(nums[:, idx])
    if len(set(x.values())) == 2:
        z = fcn(x, key=x.__getitem__)
    else:
        z = "1" if direction == "max" else "0"
    return criteria(
        nums[nums[:, idx] == z, :],
        direction=direction,
        idx=idx + 1,
    )


print(criteria(nums, direction="min") * criteria(nums, direction="max"))
```

<!-- #region heading_collapsed=true -->
## Day 4
<!-- #endregion -->

```python hidden=true
fetch_day(4)
```

```python hidden=true
import re


class Board:
    winners = []

    def __init__(self, nums):
        self.board = []
        for line in nums:
            self.board.append(
                [int(x) for x in re.sub("^ ", "", re.sub(" +", " ", line)).split(" ")]
            )
        self.board = np.array(self.board)
        self.punched = np.full([5, 5], False)
        self.last_called = 0
        self.won = False

    def punch(self, num):
        if self.won:
            return
        self.punched |= self.board == num
        self.last_called = num
        if self.check_win():
            self.winners.append(self)

    def check_win(self):
        self.won = (
            self.won
            or any(all(self.punched[x, :]) for x in range(5))
            or any(all(self.punched[:, x]) for x in range(5))
        )
        return self.won

    def get_score(self):
        return (self.board * ~self.punched).sum() * self.last_called


def parse(lines):
    return [int(x) for x in lines[0].split(",")], [
        Board(lines[idx : idx + 5]) for idx in range(2, len(lines), 6)
    ]


called, boards = parse(lines)

for call in called:
    for idx, board in enumerate(boards):
        board.punch(call)

print(Board.winners[0].get_score(), Board.winners[-1].get_score())
```

<!-- #region heading_collapsed=true -->
## Day 5
<!-- #endregion -->

```python hidden=true
fetch_day(5)
```

```python hidden=true
def parse_line(line):
    x, y = line.split(" -> ")
    x, y = x.split(","), y.split(",")
    return list(map(int, x)), list(map(int, y))


lines = list(map(parse_line, lines))

c = Counter()
c2 = Counter()
for x, y in lines:
    if x[0] == y[0]:
        m, M = min(x[1], y[1]), max(x[1], y[1])
        for idx in range(m, M + 1):
            c[(x[0], idx)] += 1
    elif x[1] == y[1]:
        m, M = min(x[0], y[0]), max(x[0], y[0])
        for idx in range(m, M + 1):
            c[(idx, x[1])] += 1
    else:
        m, n, M, N = (*x, *y)
        if n > N:
            m, M, n, N = M, m, N, n
        for idx in range(n, N + 1):
            if m < M:
                c2[(m + idx - n, idx)] += 1
            else:
                c2[(m - idx + n, idx)] += 1

print(sum(v > 1 for k, v in c.items()))
print(sum(v > 1 for k, v in (c + c2).items()))
```

<!-- #region heading_collapsed=true -->
## Day 6
<!-- #endregion -->

```python hidden=true
fetch_day(6)
```

```python hidden=true
nums = list(map(int, lines[0].split(",")))
cnums = Counter(nums)


def cevolve(cnums):
    out = Counter()
    for k, v in cnums.items():
        if k > 0:
            out[k - 1] += v
        else:
            out[6] += v
            out[8] += v
    return out


for idx in range(80):
    cnums = cevolve(cnums)
print(sum(cnums.values()))
for idx in range(256 - 80):
    cnums = cevolve(cnums)
print(sum(cnums.values()))
```

<!-- #region heading_collapsed=true -->
## Day 7
<!-- #endregion -->

```python hidden=true
fetch_day(7)
```

```python hidden=true
nums = list(map(int, lines[0].split(",")))
```

```python hidden=true
min(sum(abs(m - y) * (abs(m - y) + 1) // 2 for y in nums) for m in range(1911))
```

<!-- #region heading_collapsed=true -->
## Day 8
<!-- #endregion -->

```python hidden=true
fetch_day(8)
```

```python hidden=true
digits = [
    (1, 1, 1, 0, 1, 1, 1),
    (0, 0, 1, 0, 0, 1, 0),
    (1, 0, 1, 1, 1, 0, 1),
    (1, 0, 1, 1, 0, 1, 1),
    (0, 1, 1, 1, 0, 1, 0),
    (1, 1, 0, 1, 0, 1, 1),
    (1, 1, 0, 1, 1, 1, 1),
    (1, 0, 1, 0, 0, 1, 0),
    (1, 1, 1, 1, 1, 1, 1),
    (1, 1, 1, 1, 0, 1, 1),
]

letter_map = dict(zip(range(7), "abcdefg"))
correct_digits = [
    "".join(letter_map[idx] for idx, v in enumerate(d) if v) for d in digits
]
check = list(sorted(correct_digits))

from itertools import permutations


def apply_map(l, lmap="abcdefg"):
    lmap = dict(zip("abcdefg", list(lmap)))
    return ["".join(sorted(map(lmap.__getitem__, x))) for x in l]


def sort_letters(letters):
    letters = letters.split(" ")
    return apply_map(letters)


def parse_line(line):
    l, out = map(sort_letters, line.split(" | "))
    s = list(map(len, l))
    for perm in permutations("abcdefg"):
        l_test = apply_map(l, perm)
        if check == list(sorted(l_test)):
            out = apply_map(out, perm)
            return [correct_digits.index(x) for x in out]


sol = list(map(parse_line, tqdm(lines)))

c = sum((Counter(x) for x in sol), Counter())
print(sum(c[int(x)] for x in "1478"))
print(sum(int("".join(map(str, x))) for x in sol))
```

<!-- #region heading_collapsed=true -->
## Day 9
<!-- #endregion -->

```python hidden=true
fetch_day(9)
```

```python hidden=true
# Part 1

nums = np.array([list(map(int, x)) for x in lines])
valid = []
m, n = nums.shape


def neighbors(x, y):
    out = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
    return [(a, b) for a, b in out if 0 <= a < m and 0 <= b < n]


minimums = {
    (x, y)
    for x in range(m)
    for y in range(n)
    if all(nums[cx, cy] > nums[x, y] for cx, cy in neighbors(x, y))
}
print(sum(nums[x, y] + 1 for x, y in minimums))

# Part 2


def area(loc):
    x, y = loc
    if nums[x, y] in {-1, 9}:
        return 0
    nums[x, y] = -1
    return 1 + sum(map(area, neighbors(x, y)))


np.prod(sorted(map(area, minimums))[-3:])
```

<!-- #region heading_collapsed=true -->
## Day 10
<!-- #endregion -->

```python hidden=true
fetch_day(10)
```

```python hidden=true
match = dict(zip("([{<", ")]}>"))


def check_line(line):
    score = 0
    q = deque()
    score_map = dict(zip(")]}>", [3, 57, 1197, 25137]))
    score_map_2 = dict(zip("([{<", [1, 2, 3, 4]))
    part1, part2 = 0, 0
    try:
        for c in line:
            if c in "([{<":
                q.append(c)
            else:
                if c != match[q.pop()]:
                    part1 = score_map[c]
                    raise ValueError
    except ValueError:
        pass
    else:
        while q:
            c = q.pop()
            part2 *= 5
            part2 += score_map_2[c]
    finally:
        return part1, part2


output = list(map(check_line, lines))
print(sum(x for x, _ in output))
print(median(x for _, x in output if x > 0))
```

<!-- #region heading_collapsed=true -->
## Day 11
<!-- #endregion -->

```python hidden=true
fetch_day(11)
```

```python hidden=true
class Flash:
    def __init__(self, lines):
        self.N = len(lines)
        self.grid = np.array([list(map(int, line)) for line in lines])
        self.flashcount = 0

    def print(self):
        print(self.grid)

    def step(self):
        self.grid += 1
        flashed = True
        self.flashgrid = np.full((self.N, self.N), False)
        while flashed:
            flashed = False
            flashes = [
                (x, y)
                for x in range(self.N)
                for y in range(self.N)
                if self.grid[x, y] > 9
            ]
            flashed = bool(flashes)
            for x, y in flashes:
                self.flash(x, y)
            self.grid[self.flashgrid] = 0

    def flash(self, x, y):
        if self.flashgrid[x, y]:
            return
        self.flashgrid[x, y] = True
        self.grid[
            max(0, x - 1) : min(self.N, x + 2),
            max(0, y - 1) : min(self.N, y + 2),
        ] += 1
        self.flashcount += 1


f = Flash(lines)
for idx in range(100):
    f.step()
print(f.flashcount)
for idx in range(100000):
    f.step()
    if all(f.flashgrid.flatten()):
        print(idx + 101)
        break
```

<!-- #region heading_collapsed=true -->
## Day 12
<!-- #endregion -->

```python hidden=true
fetch_day(12)
```

```python hidden=true
graph = defaultdict(set)
for line in lines:
    x, y = line.split("-")
    if y != "start":
        graph[x].add(y)
    if x != "start":
        graph[y].add(x)

valid_walks = 0
stack = deque([(("start",), {"start"})])

while stack:
    walk, visited = stack.pop()
    for v in graph[walk[-1]] - visited:
        if v == "end":
            valid_walks += 1
        else:
            stack.append(
                (
                    walk + (v,),
                    visited | {v} if v == v.lower() else visited,
                )
            )

print(valid_walks)
```

```python hidden=true
graph = defaultdict(set)
for line in lines:
    x, y = line.split("-")
    if y != "start":
        graph[x].add(y)
    if x != "start":
        graph[y].add(x)

valid_walks = 0
stack = deque([(("start",), {"start"}, False)])

while stack:
    walk, visited, visited_twice = stack.pop()
    for v in graph[walk[-1]]:
        if v == "end":
            valid_walks += 1
        elif v not in visited or not visited_twice:
            stack.append(
                (
                    walk + (v,),
                    visited | {v} if v == v.lower() else visited,
                    visited_twice or (v in visited),
                )
            )

print(valid_walks)
```

<!-- #region heading_collapsed=true -->
## Day 13
<!-- #endregion -->

```python hidden=true
fetch_day(13)
```

```python hidden=true
it = iter(lines)
points = set()
folds = []
while line := next(it):
    points.add(tuple(map(int, line.split(","))))
for line in it:
    eq_idx = line.find("=")
    folds.append((line[eq_idx - 1], int(line[eq_idx + 1 :])))


def transform(points, fold):
    d, z = fold
    if d == "x":
        return {(min(x, 2 * z - x), y) for x, y in points}
    else:
        return {(x, min(y, 2 * z - y)) for x, y in points}


print(len(transform(points, folds[0])))

for fold in folds:
    points = transform(points, fold)

M, N = max(x for x, _ in points), max(y for _, y in points)
grid = np.full((M + 1, N + 1), " ")

for x, y in points:
    grid[x, y] = "█"
print("\n".join("".join(row) for row in grid.T))
```

<!-- #region heading_collapsed=true -->
## Day 14
<!-- #endregion -->

```python hidden=true
fetch_day(14)
```

```python hidden=true
chem = lines[0]
rules = dict(line.split(" -> ") for line in lines[2:])
adj = Counter(chem[i : i + 2] for i in range(len(chem) - 1))
for iterations in (10, 40):
    for _ in range(iterations):
        update = Counter()
        for k, v in adj.items():
            if k in rules:
                update[k] -= v
                update[k[0] + rules[k]] += v
                update[rules[k] + k[1]] += v
        adj += update

    c = Counter()
    for k, v in adj.items():
        c[k[0]] += v
    c[chem[-1]] += 1
    l = [v for k, v in c.items()]
    print(max(l) - min(l))
```

<!-- #region heading_collapsed=true -->
## Day 15
<!-- #endregion -->

```python hidden=true
fetch_day(15)
```

```python hidden=true
def neighbors(x, y, M, N):
    potential = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]
    return [(x, y) for x, y in potential if 0 <= x < M and 0 <= y < N]

def dijkstra(grid, source=(0, 0), target=None):
    M, N = grid.shape
    if target is None:
        target = (M - 1, N - 1)
    heap = [(0, source)]
    min_dists = defaultdict(lambda: math.inf, {source: 0})
    visited = set()
    while heap:
        dist, node = heapq.heappop(heap)
        if node == target:
            return dist
        elif node in visited:
            continue
        else:
            visited.add(node)
            for neighbor in neighbors(*node, M, N):
                if neighbor in visited:
                    continue
                elif (newdist:=dist + grid[neighbor]) < min_dists[neighbor]:
                    min_dists[neighbor] = newdist
                    heapq.heappush(heap, (newdist, neighbor))
    return math.inf

smallgrid = np.array([list(map(int, line)) for line in lines])
M, N = smallgrid.shape
biggrid = np.block(
    [[(smallgrid + i + j - 1) % 9 + 1 for j in range(5)] for i in range(5)]
)
dijkstra(smallgrid), dijkstra(biggrid)
```

<!-- #region heading_collapsed=true -->
## Day 16
<!-- #endregion -->

```python hidden=true
fetch_day(16)
```

```python hidden=true
import uuid

class Packet:
    def __init__(self, data):
        if isinstance(data, str):
            data = bin(int(data, 16))[2:].zfill(4 * len(data))
        self.data = iter(data)
        self.subpackets, self.packet_len = [], 0
        self.version, self.type_id = self.get_num(3), self.get_num(3)
        self.hash = uuid.uuid4()
        if self.type_id == 4:
            num = ""
            while True:
                d = self.get_bits(5)
                num += d[1:]
                if d[0] == "0":
                    break
            self.value = int(num, 2)
        else:
            if self.get_num(1):
                for _ in range(self.get_num(11)):
                    self.subpackets.append(Packet(self.data))
                    self.packet_len += self.subpackets[-1].packet_len
            else:
                remaining_bits = self.get_num(15)
                while remaining_bits:
                    self.subpackets.append(Packet(self.data))
                    self.packet_len += self.subpackets[-1].packet_len
                    remaining_bits -= self.subpackets[-1].packet_len

    def get_num(self, n):
        return int(self.get_bits(n), 2)

    def get_bits(self, n):
        self.packet_len += n
        return "".join(next(self.data) for _ in range(n))

    def version_sum(self):
        return self.version + sum(x.version_sum() for x in self.subpackets)

    def __repr__(self):
        if self.subpackets:
            return f"Packet(version={self.version}, type_id={self.type_id}, subpackets={self.subpackets}, hash={self.hash})"
        else:
            return f"Packet(version={self.version}, type_id={self.type_id}, value={self.value}, hash={self.hash})"

    @lru_cache
    def eval(self):
        ops = {
            0: lambda sp: sum(sp),
            1: lambda sp: math.prod(sp),
            2: lambda sp: min(sp),
            3: lambda sp: max(sp),
            4: lambda sp: self.value,
            5: lambda sp: int(next(sp) > next(sp)),
            6: lambda sp: int(next(sp) < next(sp)),
            7: lambda sp: int(next(sp) == next(sp)),
        }
        return ops[self.type_id](map(Packet.eval, self.subpackets))


p = Packet(lines[0])
print(p.version_sum(), p.eval())
```

```python hidden=true
import pydot
from networkx.drawing.nx_pydot import graphviz_layout
import matplotlib.pyplot as plt

g = nx.DiGraph()
it = iter(range(1000))
labels = {}
edge_labels = {}
op_labels = dict(zip(range(8), "+×↓↑_><="))


def format_number(n, precision=4):
    return n if n < 10 ** precision else f"{str(n)[0]}e{len(str(n)) - 1}"


def populate_graph(g, node):
    g.add_node(node.hash)
    if node.subpackets:
        labels[node.hash] = op_labels[node.type_id]
    else:
        labels[node.hash] = format_number(node.value)
    for c in node.subpackets:
        g.add_node(c.hash)
        g.add_edge(c.hash, node.hash)
        edge_labels[(c.hash, node.hash)] = format_number(c.eval(), precision=6)
        populate_graph(g, c)


populate_graph(g, p)
pos = graphviz_layout(g, prog="twopi")
fig, ax = plt.subplots(figsize=(40, 40))

nx.draw(
    g,
    pos,
    labels=labels,
    node_size=1000,
    node_color="teal",
    node_shape="s",
    font_color="white",
    font_weight="bold",
    ax=ax,
    edge_color="#222222",
    style=":",
)
nx.draw_networkx_edge_labels(
    g,
    pos,
    edge_labels=edge_labels,
    ax=ax,
    bbox=dict(boxstyle="round", alpha=0.3, ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)),
#     verticalalignment="bottom",
#     horizontalalignment="right",
    rotate=True,
    font_weight="bold",
)
plt.show()
```

## Day 17

```python
fetch_day(17)
```

```python
class Target:
    def __init__(self, data):
        self.xm, self.xM, self.ym, self.yM = map(
            int, re.search(r"(-?\d+)..(-?\d+), y=(-?\d+)..(-?\d+)", data).groups()
        )

    def __contains__(self, pos):
        x, y = pos
        return self.xm <= x <= self.xM and self.ym <= y <= self.yM

    def fire(self, vx, vy):
        x, y, maxh = 0, 0, 0
        while vy > 0 or y >= self.ym:
            x, y, vx, vy = x + vx, y + vy, vx - np.sign(vx), vy - 1
            maxh = max(maxh, y)
            if (x, y) in self:
                return maxh
        return -math.inf

    def solve(self):
        self.trials = {
            (vx, vy): h
            for vx in range(int((2 * self.xm) ** 0.5), self.xM + 1)
            for vy in range(min(0, self.ym), -self.ym)
            if (h := self.fire(vx, vy)) > -math.inf
        }
        return max(self.trials.values()), len(self.trials)


print(Target(lines[0]).solve())
```

## Day 18

```python
fetch_day(18)
```

```python
@dataclass
class Node:
    value: int
    depth: int

    def __repr__(self):
        return str(self.value)

    def __add__(self, other):
        assert self.depth == other.depth
        return Node(self.value + other.value, self.depth - 1)


class Snailfish:
    def __init__(self, init):
        nodes = list(self.parse(init)) if isinstance(init, str) else deepcopy(init)
        while True:
            try:
                for idx, node in enumerate(nodes):
                    if node.depth >= 5:
                        if idx > 0:
                            nodes[idx - 1].value += node.value
                        if idx < len(nodes) - 2:
                            nodes[idx + 2].value += nodes[idx + 1].value
                        nodes[idx] = Node(0, nodes.pop(idx).depth - 1)
                        raise StopIteration
                for idx, node in enumerate(nodes):
                    if node.value >= 10:
                        x = node.value // 2
                        y = node.value - x
                        nodes[idx] = Node(y, node.depth + 1)
                        nodes.insert(idx, Node(x, node.depth + 1))
                        raise StopIteration
            except StopIteration:
                pass
            else:
                break
        self.nodes = nodes

    @staticmethod
    def parse(line):
        s = 0
        for c in line:
            s += (c == "[") - (c == "]")
            if c.isnumeric():
                yield Node(int(c), s)

    def __add__(self, other):
        if isinstance(other, str):
            other = Snailfish(other)
        elif isinstance(other, int) and other == 0:
            return self
        s = deepcopy(self.nodes + other.nodes)
        for node in s:
            node.depth += 1
        return Snailfish(s)

    def __radd__(self, other):
        return self + other

    def __repr__(self):
        return repr(self.nodes)

    def magnitude(self):
        s = deepcopy(self.nodes)
        while True:
            try:
                for i in range(len(s) - 1):
                    if s[i].depth == s[i + 1].depth:
                        raise StopIteration
            except StopIteration:
                s[i] = Node(3 * s.pop(i).value + 2 * s[i].value, s[i].depth - 1)
            else:
                break
        return s[0].value


sf = list(map(Snailfish, lines))
print(sum(sf).magnitude())
print(max((x + y).magnitude() for x in sf for y in sf if x is not y))
```
